# Соревнование Spaceship Titanic
## Оглавление
1. [Описание](#описание)
2. [Визуализация](#визуализация)
    1. [Визуализация](#визуализация)
    2. [Визуализация](#визуализация)
    3. [Визуализация](#визуализация)
4. [Анализ данных](#анализ-данных)
5. [Подготовка данных](#подготовка-данных)
6. [Выбор модели](#выбор-модели)
7. [Обучение модели](#обучение-модели)
8. [Предсказание](#предсказание)
9. [Оценка и результаты](#оценка-и-результаты)
10. [Заключение](#заключение)

## Описание
В 2912 году корабль "Spaceship Titanic" столкнулся с пространственно-временной аномалией, и половина пассажиров была перемещена в альтернативное измерение. Вам предстоит по записям из поврежденной компьютерной системы определить, какие пассажиры были затронуты аномалией.

## Анализ данных:
Мой путь в этом соревновании начался с внимательного анализа предоставленных данных. После осмотра выборок train и test стало ясно, что передо мной стоит задача работы с пятью категориальными и семью количественными признаками. Это первый шаг, который помог мне в разработке стратегии для создания модели. 

```python
train_data.head()
```

```python
train_data.info()
```

```python
train_data.describe()
```
```python
test_data.head()
```

Стоит отметить, что анализ показал наличие пропущенных значений в данных. Это выявление стало важным этапом, так как понимание, какие признаки и насколько подвержены пропущенным значениям, будет влиять на последующий этап обработки данных. 

## Визуализация:
Прежде чем приступать к подготовке данных, я решил визуализировать имеющуюся информацию, чтобы понять с чем мне предстоит работать.

### График распределения возрата:
<div style="text-align: center;">
    <img src="https://github.com/Lapamore/Kaggle_competitions/blob/main/Spaceship%20Titanic/img/hist.png" alt="График распределения возрата" width="550" height="400">
</div>
Заметно, что основная часть пассажиров космического корабля находится в возрастной группе от 13 до 38 лет.

### График Boxplot
<div style="text-align: center;">
    <img src="https://github.com/Lapamore/Kaggle_competitions/blob/main/Spaceship%20Titanic/img/boxplot.png" alt="График Boxplot" width="500" height="400">
</div>
Анализ графика Boxplot позволяет выявить наличие выбросов в данных столбца "Age". Это нюанс, который мы учтем при последующей обработке.

### График корреляции:
<div style="text-align: center;">
    <img src="https://github.com/Lapamore/Kaggle_competitions/blob/main/Spaceship%20Titanic/img/corr.png" alt="График корреляции" width="500" height="400">
</div>
Изучая матрицу корреляции, можно выделить переменные, между которыми наблюдается высокая степень взаимосвязи.

## Подготовка данных:
Перед тем, как приступать к обработке данных я создал 4 функции:
- FeatureEncoder - преобразует категориальные признаки в в числовой формат.
```python
def FeatureEncoder(X):
    encoder = OneHotEncoder()
    matrix = encoder.fit_transform(X[['Embarked']]).toarray()

    column_names = ["C", "S", "Q", "N"]

    for i in range(len(matrix.T)):
        X[column_names[i]] = matrix.T[i]

    matrix = encoder.fit_transform(X[['Sex']]).toarray()  
    column_names = ["Female", "Male"]

    for i in range(len(matrix.T)):
        X[column_names[i]] = matrix.T[i]

    return X
```
- drop_features - удаляет ненужные столбцы
```python
def drop_features(X):
    return X.drop(['Name','Cabin', 'PassengerId', 'Destination', 'HomePlanet', 'Deck'], axis=1 , errors='ignore')
```
- fill_value - заполняет пропущенные данные
  ```python
    def fill_value(X):
    for col in X.columns:
        if X[col].isnull().sum() == 0:
            continue

        if X[col].dtype == object or X[col].dtype == bool:
            X[col] = X[col].fillna(X[col].mode()[0])

        else:
            X[col] = X[col].fillna(X[col].mean())
    ```
- add_new_feature - добавляет новые столбцы
 ```python
def add_new_feature(X): 
    deck = X['Cabin'].map(lambda x: x.split("/") if isinstance(x, str) else [])
    
    X['Group'] = X['PassengerId'].map(lambda x: x.split("_")).apply(lambda x: int(x[1]))
    X['Deck'] = deck.apply(lambda x: x[0] if len(x) > 0 else None)
    X['Side'] = deck.apply(lambda x: x[2] if len(x) > 0 else None)
    return X
```

## Обработке и предобработка данных для обучения модели:
### Обработка категориальных признаков
После того как я провёл предварительную обработку данных, настал момент решения, как эффективно работать с категориальными признаками. Одним из наиболее распространённых методов является OneHotEncoding, который позволяет перевести категориальные переменные в числовой формат, при этом избегая ненужной упорядоченности или искажения значений.

Для применения OneHotEncoding к данным я создал функцию FeatureEncoder, которая автоматизировала этот процесс. Применяя её к train выборке, я смог преобразовать категориальные признаки в бинарные столбцы, что позволило модели учитывать разные категории в независимости друг от друга.



С учетом сделанных исключений, я сформировал переменную X, включающую в себя dataframe без столбца Survived, который содержит правильные ответы. Вектор правильных ответов (Survived) я поместил в переменную y. Это предоставило мне четкое разделение между входными признаками и целевой переменной, что является фундаментом для дальнейшего построения и обучения модели.
```python
X = DropFeatures(train_data)
y = train['Survived']
```
### Масштабирование данных
Для повышения эффективности обучения модели я применил метод масштабирования данных. Это важный этап предобработки, который позволяет привести все признаки к общему масштабу и диапазону значений. 

Я использовал стандартизацию (StandardScaler) из библиотеки `scikit-learn`, которая масштабирует признаки так, чтобы среднее значение стало равным 0, а стандартное отклонение - 1.

```python
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
y_scaled = y.to_numpy()
```
### Разделение на тренировочную и тестовую выборки
После всех этапов предобработки данных, следующим шагом было разделение данных на тренировочную и тестовую выборки. Это позволяет оценить качество обучения модели на отложенных данных и проверить, насколько успешно модель будет работать на новых наборах данных.

Для этого я использовал функцию `train_test_split` из библиотеки `scikit-learn`, которая случайным образом разбивает данные на две части: одну для обучения модели (тренировочную выборку) и другую для оценки её производительности (тестовую выборку).

```python
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=.3, random_state=17) 
```

## Выбор модели:
Из всех моделей я решил выбрать `RandomForestClassifier`. Мой выбор обусловлен несколькими факторами:

- Во-первых, случайный лес является ансамблевым методом, который объединяет множество деревьев решений для улучшения обобщающей способности модели. Это позволяет избежать переобучения и учесть разнообразие признаков.
- Во-вторых, случайный лес хорошо справляется с задачами классификации, так как способен обрабатывать как количественные, так и категориальные признаки. Учитывая многообразие данных в задаче предсказания выживаемости, я считаю, что этот метод может дать хорошие результаты.
 
## Обучение модели
Для настройки параметров модели и достижения наилучшей производительности, я применил метод `GridSearchCV`. Этот метод позволяет обучать модель на кросс-валидации, автоматически перебирая различные комбинации заданных параметров.

В результате, переменная с наилучшими параметрами модели будет создана автоматически. Это позволяет упростить и ускорить процесс поиска наиболее оптимальных параметров для данной выборки данных.

```python
clf = RandomForestClassifier(random_state=17)

params = {
    'n_estimators':[10, 100, 200, 500, 600],
    'max_depth':[None, 5, 10],
    "min_samples_split": [2, 3 ,4],
}

search = GridSearchCV(clf, params, cv=3, scoring='accuracy')
search.fit(X_train, y_train)

best_model = search.best_estimator_
best_model.score(X_test, y_test)
```
Accuracy на X_test и y_test = 0.802

## Предсказание
Пройдя через все этапы обработки и настройки модели, я перешел к фазе предсказания. Для этого использовал обученную модель с наилучшими параметрами.

```python
pred = best_model.predict(X_data_final_test)
```

После выполнения предсказаний, я создал dataframe, где каждому человеку предсказано, выживет ли он или нет. Это позволило оценить, какие пассажиры, возможно, имеют больший шанс выжить на основе разработанной модели.

```python
df_pred = pd.DataFrame(test['PassengerId'])
df_pred['Survived'] = pred 
df_pred.to_csv("predictions/Titanic prediction.csv", index=False)
```

## Оценка и результаты
Следующим этапом работы стала загрузка `Titanic prediction.csv` на платформу Kaggle, где я оценил точность своей модели предсказания на тестовой выборке.

![Accuracy](https://github.com/Lapamore/Kaggle_competitions/blob/main/Titanic/img/score_2.png?raw=true)

После загрузки предсказаний на платформу Kaggle, я получил оценку точности моей модели на основе метрики, предоставленной в задаче. Это позволило мне понять, насколько успешно моя модель обобщает данные и делает предсказания на новых данных.

![Место в таблице](https://github.com/Lapamore/Kaggle_competitions/blob/main/Titanic/img/score.png?raw=true)

Этот этап закрывает мой проект и дает понимание того, насколько успешно моя модель справляется с задачей предсказания выживаемости на "Титанике".

## Заключение
На этом этапе я заканчиваю свое описание решения поставленной задачи. Хотелось бы подчеркнуть, что именно это соревнование помогло мне разобраться со многими недопониманиями. Надеюсь, что Вы оцените мое решение. Спасибо!
